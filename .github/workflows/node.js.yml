name: Node.js CI

on:
  push:
    branches: ["main"]
  workflow_dispatch:

defaults:
  run:
    shell: bash

jobs:
  build:
    runs-on: self-hosted
    timeout-minutes: 30

    # Expose secrets as environment variables
    env:
      DB_NAME: "${{ secrets.DB_NAME }}"
      DATABASE_URL: "${{ secrets.DATABASE_URL }}"
      PORT: "${{ secrets.PORT }}"
      API_PRIFEX: "${{ secrets.API_PRIFEX }}"
      SECRET_KEY: "${{ secrets.SECRET_KEY }}"
      MAIL_SERVICE: "${{ secrets.MAIL_SERVICE }}"
      MAIL_HOST: "${{ secrets.MAIL_HOST }}"
      MAIL_USERNAME: "${{ secrets.MAIL_USERNAME }}"
      MAIL_PASSWORD: "${{ secrets.MAIL_PASSWORD }}"
      MAIL_ENCRYPTION: "${{ secrets.MAIL_ENCRYPTION }}"
      MAIL_PORT: "${{ secrets.MAIL_PORT }}"
      MAIL_FROM_NAME: "${{ secrets.MAIL_FROM_NAME }}"
      STRIPE_KEY: "${{ secrets.STRIPE_KEY }}"
      END_POINT_SECRET: "${{ secrets.END_POINT_SECRET }}"
      ACCESS_KEY_ID: "${{ secrets.ACCESS_KEY_ID }}"
      SECRET_ACCESS_KEY: "${{ secrets.SECRET_ACCESS_KEY }}"
      BUCKET_REGION: "${{ secrets.BUCKET_REGION }}"
      BUCKET_NAME: "${{ secrets.BUCKET_NAME }}"
      S3_ACCESS_URL: "${{ secrets.S3_ACCESS_URL }}"

    steps:
      # 1) Sanity info
      - name: Kickoff
        run: |
          set -x
          echo "== CI kickoff at $(date -u) =="
          echo "Runner: $(uname -a)"
          whoami
          node -v || true
          npm -v || true

      # 2) Checkout
      - name: Checkout
        uses: actions/checkout@v4

      # 3) Create .env from secrets (validated)
      - name: Create .env from secrets
        run: |
          set -euo pipefail
          DB_URL_VALUE="${DATABASE_URL:-${DATABASE_URL:-}}"
          if [ -z "${DB_URL_VALUE}" ]; then
            echo "ERROR: DATABASE_URL resolved to empty"; exit 1
          fi

          rm -f .env
          {
            printf '%s\n' "DATABASE_URL=${DB_URL_VALUE}"
            printf '%s\n' "NODE_ENV=production"
            printf '%s\n' "PORT=${PORT}"
            printf '%s\n' "API_PRIFEX=${API_PRIFEX}"
            printf '%s\n' "SECRET_KEY=${SECRET_KEY}"
            printf '%s\n' "MAIL_SERVICE=${MAIL_SERVICE}"
            printf '%s\n' "MAIL_HOST=${MAIL_HOST}"
            printf '%s\n' "MAIL_USERNAME=${MAIL_USERNAME}"
            printf '%s\n' "MAIL_PASSWORD=${MAIL_PASSWORD}"
            printf '%s\n' "MAIL_ENCRYPTION=${MAIL_ENCRYPTION}"
            printf '%s\n' "MAIL_PORT=${MAIL_PORT}"
            printf '%s\n' "MAIL_FROM_NAME=${MAIL_FROM_NAME}"
            printf '%s\n' "STRIPE_KEY=${STRIPE_KEY}"
            printf '%s\n' "END_POINT_SECRET=${END_POINT_SECRET}"
            printf '%s\n' "ACCESS_KEY_ID=${ACCESS_KEY_ID}"
            printf '%s\n' "SECRET_ACCESS_KEY=${SECRET_ACCESS_KEY}"
            printf '%s\n' "BUCKET_REGION=${BUCKET_REGION}"
            printf '%s\n' "BUCKET_NAME=${BUCKET_NAME}"
            printf '%s\n' "S3_ACCESS_URL=${S3_ACCESS_URL}"
          } >> .env
          echo "Wrote .env with $(wc -l < .env) lines."
          if ! grep -q '^DATABASE_URL=' .env; then
            echo "ERROR: DATABASE_URL not written to .env"; exit 1
          fi
          LEN="$(awk -F= '/^DATABASE_URL=/{print length($2)}' .env)"
          if [ "${LEN}" -eq 0 ]; then
            echo "ERROR: DATABASE_URL in .env is empty"; exit 1
          fi

      # 4) Node setup
      - name: Use Node.js 22.x
        uses: actions/setup-node@v4
        with:
          node-version: 22.x
          cache: npm

      # 5) Install deps
      - name: Install dependencies
        run: npm ci --loglevel=verbose --foreground-scripts

      # 6) Build + Prisma (generate + migrate)
      - name: Build & Prisma migrate (safe)
        env:
          # Prisma reads from .env for DATABASE_URL
          PRISMA_HIDE_UPDATE_MESSAGE: "true"
        run: |
          set -euxo pipefail
          echo "=== build (if present) ==="
          npm run build --if-present

          echo "=== prisma generate ==="
          npx prisma generate

          # One-time, idempotent: record existing migrations as applied if the target DB has no history yet.
          echo "=== prisma baseline resolve (best-effort) ==="
          # Best-effort baseline so existing production databases gain Prisma migration history without wiping data
          set +e  # Allow the discovery probe to fail without aborting the job
          npx prisma db execute --schema prisma/schema.prisma --command "SHOW TABLES LIKE '_prisma_migrations';" | grep -q '_prisma_migrations'
          HAS_MIGRATION_HISTORY=$?
          set -e
          if [ "$HAS_MIGRATION_HISTORY" -eq 0 ]; then
            echo "Prisma migration history already present; skipping baseline resolve."
          else
            echo "No migration history detected; marking existing migrations as applied for baseline."
            for MIGRATION_PATH in prisma/migrations/*/; do
              MIGRATION_NAME="$(basename "$MIGRATION_PATH")"
              echo "Marking migration $MIGRATION_NAME as applied (best-effort baseline)."
              npx prisma migrate resolve --applied "$MIGRATION_NAME" || true
            done
          fi

          echo "=== prisma migrate deploy ==="
          npx prisma migrate deploy

      # 7) Ensure PM2 is installed
      - name: Ensure PM2 installed
        run: |
          command -v pm2 >/dev/null 2>&1 || sudo npm i -g pm2
          pm2 -v

      # 8) Start/Reload app with PM2
      - name: Start/Reload app with PM2
        run: |
          set -euo pipefail
          APP_NAME="cutsy-backend"
          START_SCRIPT="index.js"   # change if your entry file differs

          if pm2 describe "${APP_NAME}" >/dev/null 2>&1; then
            pm2 reload "${APP_NAME}" --update-env
          else
            pm2 start "${START_SCRIPT}" --name "${APP_NAME}"
          fi
          # remove any old unnamed/legacy process if present
          pm2 delete index || true
          pm2 save

      # 9) Show startup logs
      - name: Show startup logs
        run: |
          set -x
          pm2 status || true
          tail -n 120 ~/.pm2/logs/cutsy-backend-out.log   || true
          tail -n 120 ~/.pm2/logs/cutsy-backend-error.log || true

      # 10) Health check
      - name: Health check
        run: |
          set -e
          URL="http://127.0.0.1:${PORT:-4000}/health"
          for i in {1..30}; do
            if curl -fsS "$URL" >/dev/null; then
              echo "Health check passed at $(date -u)"
              exit 0
            fi
            echo "Waiting for app... ($i/30)"
            sleep 2
          done
          echo "Health check FAILED"
          tail -n 200 ~/.pm2/logs/cutsy-backend-out.log   || true
          tail -n 200 ~/.pm2/logs/cutsy-backend-error.log || true
          exit 1

      # 11) Final status & logs
      - name: PM2 status & recent logs
        run: |
          pm2 status
          timeout 8s pm2 logs cutsy-backend --lines 80 --nostream || true
